<!DOCTYPE html>
<html lang="zh-Hant">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>AI é«”æ„Ÿç©¿æ­èˆ‡å¦å®¹æ¨è–¦ Demo</title>
	<style>
		body {
			background-color: #e0f7fa;
			font-family: Arial, sans-serif;
			text-align: center;
			margin: 0;
		}
		header, footer {
			background-color: #00acc1;
			color: white;
			padding: 1rem;
		}
		h1 {
			margin-top: 1rem;
			color: white;
		}
		.feature {
			margin: 2rem auto;
			max-width: 800px;
			background: white;
			padding: 1.5rem;
			border-radius: 16px;
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
		}
		video, canvas {
			max-width: 90%;
			border: 2px solid #00acc1;
			border-radius: 8px;
		}
		.share-buttons img {
			width: 32px;
			margin: 0 0.5rem;
			cursor: pointer;
		}
	</style>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
	<header>
		<h1>AI é«”æ„Ÿäº’å‹•æ™‚å°šæ¨è–¦å¹³å°</h1>
	</header>

	<div class="feature">
		<h2>ğŸ§  è‡‰éƒ¨åˆ†ææ¨è–¦å¦æ„Ÿé¢¨æ ¼</h2>
		<p>ç³»çµ±å°‡åˆ†æä½ çš„è‡‰å‹ï¼ˆå¦‚éµè›‹è‡‰ã€åœ“è‡‰ã€é•·è‡‰ç­‰ï¼‰ã€çœ¼è·èˆ‡è†šè‰²ï¼Œæ¨è–¦æœ€é©åˆçš„å¦å®¹é¢¨æ ¼ï¼ˆå¦‚è‡ªç„¶ã€ç”œç¾ã€éŠ³åˆ©é¢¨ï¼‰ï¼Œä¸¦æ­é…é©åˆçš„é«®å‹è¨­è¨ˆã€‚</p>
		<video id="faceVideo" autoplay muted playsinline></video>
		<canvas id="faceCanvas"></canvas>
        <div id="faceStatus">ğŸ” è«‹å°‡è‡‰å°æº–é¡é ­é€²è¡Œåˆ†æ...</div>
        <pre id="faceResult" style="text-align:left; padding:1rem; background:#f1f1f1; border-radius:8px;"></pre>
		<div class="share-buttons">
			<img src="https://cdn-icons-png.flaticon.com/512/733/733547.png" alt="Facebook åˆ†äº«" title="åˆ†äº«åˆ° Facebook" />
			<img src="https://cdn-icons-png.flaticon.com/512/2111/2111463.png" alt="Instagram åˆ†äº«" title="åˆ†äº«åˆ° Instagram" />
		</div>
	</div>

	<div class="feature">
		<h2>ğŸ’ƒ å…¨èº«éª¨æ¶åˆ†æç©¿æ­å»ºè­°</h2>
		<p>é€ééª¨æ¶åµæ¸¬æŠ€è¡“è¾¨è­˜ä½ çš„èº«å½¢æ¯”ä¾‹ï¼ˆå¦‚äº”äº”èº«ã€å››å…­èº«ï¼‰ã€è‚©å¯¬ã€è…¿é•·ç­‰ï¼Œä¸¦æ¨è–¦æœ€é©åˆä½ çš„æœé£¾å‰ªè£ï¼ˆå¦‚å¯¬é¬†ã€ä¿®èº«ï¼‰ã€æ­é…é¢¨æ ¼èˆ‡é¡è‰²ã€‚</p>
		<video id="poseVideo" autoplay muted playsinline></video>
		<canvas id="poseCanvas"></canvas>
        <div id="poseResult" style="margin-top: 1rem; color: #00796b;"></div>
		<div class="share-buttons">
			<img src="https://cdn-icons-png.flaticon.com/512/733/733547.png" alt="Facebook åˆ†äº«" title="åˆ†äº«åˆ° Facebook" />
			<img src="https://cdn-icons-png.flaticon.com/512/2111/2111463.png" alt="Instagram åˆ†äº«" title="åˆ†äº«åˆ° Instagram" />
		</div>
	</div>

	<footer>
		<p>&copy; 2025 AI Style Recommender | Designed by æ´ªç¿Šå˜‰</p>
	</footer>

	<script>
		const faceVideo = document.getElementById('faceVideo');
		const faceCanvas = document.getElementById('faceCanvas');
		const poseVideo = document.getElementById('poseVideo');
		const poseCanvas = document.getElementById('poseCanvas');

		const faceMesh = new FaceMesh({
			locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
		});
		faceMesh.setOptions({
			maxNumFaces: 1,
			refineLandmarks: true,
			minDetectionConfidence: 0.5,
			minTrackingConfidence: 0.5
		});

		faceMesh.onResults(results => {
	        const ctx = faceCanvas.getContext('2d');
	        if (faceVideo.readyState >= 2) {
		        faceCanvas.width = faceVideo.videoWidth;
		        faceCanvas.height = faceVideo.videoHeight;
	        }
	        ctx.clearRect(0, 0, faceCanvas.width, faceCanvas.height);
	        if (results.multiFaceLandmarks) {
	            document.getElementById("faceStatus").innerText = "âœ… åµæ¸¬åˆ°è‡‰éƒ¨ï¼Œåˆ†æä¸­...";
	            // ...ç¹ªåœ–é‚è¼¯
            } else {
	            document.getElementById("faceStatus").innerText = "ğŸ” ç„¡æ³•åµæ¸¬è‡‰éƒ¨ï¼Œè«‹é è¿‘ä¸€é»æˆ–èª¿æ•´è§’åº¦";
            }

	        let output = '';
	        if (results.multiFaceLandmarks) {
		        for (const landmarks of results.multiFaceLandmarks) {
			        for (const point of landmarks) {
				        ctx.beginPath();
				        ctx.arc(point.x * faceCanvas.width, point.y * faceCanvas.height, 2, 0, 2 * Math.PI);
				        ctx.fillStyle = '#00acc1';
				        ctx.fill();
			        }

			        // è‡‰å‹åˆ†æ
			        const jawLeft = landmarks[234];
			        const jawRight = landmarks[454];
			        const chin = landmarks[152];
			        const forehead = landmarks[10];
			        const width = Math.abs(jawRight.x - jawLeft.x);
			        const height = Math.abs(chin.y - forehead.y);
			        const ratio = height / width;

			        if (ratio > 1.35) {
				        output += 'è‡‰å‹ï¼šé•·è‡‰ï¼Œå»ºè­°å´åˆ†ç€æµ·æˆ–ä¸­åˆ†ä¿®é£¾é•·åº¦ã€‚\n';
			        } else if (ratio < 1.1) {
				        output += 'è‡‰å‹ï¼šåœ“è‡‰ï¼Œæ¨è–¦æœ‰å±¤æ¬¡çš„çŸ­é«®æˆ–å´é‚Šç€æµ·ä¿®é£¾ã€‚\n';
			        } else {
				        output += 'è‡‰å‹ï¼šéµè›‹è‡‰ï¼Œé©åˆå¤šç¨®å¦æ„Ÿèˆ‡é«®å‹ã€‚\n';
			        }

			        // è†šè‰²åˆ†æ
			        const keyPoints = [landmarks[168], landmarks[6], landmarks[197]];
			        const sampleX = keyPoints.map(p => Math.round(p.x * faceCanvas.width));
			        const sampleY = keyPoints.map(p => Math.round(p.y * faceCanvas.height));

			        const imageData = ctx.getImageData(
				        Math.min(...sampleX),
				        Math.min(...sampleY),
				        Math.max(...sampleX) - Math.min(...sampleX) || 1,
				        Math.max(...sampleY) - Math.min(...sampleY) || 1
			        );
			        let r = 0, g = 0, b = 0;
			        for (let i = 0; i < imageData.data.length; i += 4) {
				        r += imageData.data[i];
				        g += imageData.data[i + 1];
				        b += imageData.data[i + 2];
			        }
			        const pixelCount = imageData.data.length / 4;
			        r = Math.round(r / pixelCount);
			        g = Math.round(g / pixelCount);
			        b = Math.round(b / pixelCount);

			        // æ ¹æ“š RGB åˆ¤æ–·å†·æš–èª¿
			        if (r > b && g > b && r - b > 20) {
				        output += `è†šè‰²ï¼šæš–èª¿ï¼ˆåé»ƒæˆ–æ©„æ¬–è‚Œï¼‰\nå¦å®¹å»ºè­°ï¼šä½¿ç”¨çŠç‘šæ©˜ã€æ©˜æ£•ã€å¥¶èŒ¶è‰²èª¿ã€‚\n`;
			        } else {
				        output += `è†šè‰²ï¼šå†·èª¿ï¼ˆåç™½æˆ–ç²‰è†šï¼‰\nå¦å®¹å»ºè­°ï¼šä½¿ç”¨è“ç´…ã€ç«ç‘°ç´«ã€ç²‰è£¸è‰²èª¿ã€‚\n`;
			        }
		        }
	        }
	        document.getElementById('faceResult').innerText = output || 'æœªåµæ¸¬åˆ°è‡‰éƒ¨';
        });

		const pose = new Pose({
			locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
		});

		pose.setOptions({
			modelComplexity: 1,
			smoothLandmarks: true,
			enableSegmentation: false,
			minDetectionConfidence: 0.5,
			minTrackingConfidence: 0.5
		});

		pose.onResults(results => {
	        const ctx = poseCanvas.getContext('2d');
	        if (poseVideo.readyState >= 2) {
		        poseCanvas.width = poseVideo.videoWidth;
		        poseCanvas.height = poseVideo.videoHeight;
	        }
	        ctx.clearRect(0, 0, poseCanvas.width, poseCanvas.height);
	        let output = '';
	        if (results.poseLandmarks) {
		        const lm = results.poseLandmarks;
		        const connect = (i, j) => {
			        ctx.beginPath();
			        ctx.moveTo(lm[i].x * poseCanvas.width, lm[i].y * poseCanvas.height);
			        ctx.lineTo(lm[j].x * poseCanvas.width, lm[j].y * poseCanvas.height);
			        ctx.strokeStyle = '#ffccbc';
			        ctx.lineWidth = 2;
			        ctx.stroke();
		        };
		        // ç¹ªè£½é—œç¯€é»
		        for (const point of lm) {
			        ctx.beginPath();
			        ctx.arc(point.x * poseCanvas.width, point.y * poseCanvas.height, 4, 0, 2 * Math.PI);
			        ctx.fillStyle = '#ff7043';
			        ctx.fill();
		        }
		        // éª¨æ¶é€£ç·š
		        const pairs = [
			        [11, 13], [13, 15], // å·¦è‡‚
			        [12, 14], [14, 16], // å³è‡‚
			        [11, 12],           // è‚©è†€
			        [11, 23], [12, 24], // å´èº«
			        [23, 24],           // éª¨ç›†
			        [23, 25], [25, 27], // å·¦è…¿
			        [24, 26], [26, 28]  // å³è…¿
		        ];
		        pairs.forEach(pair => connect(...pair));

		        // èº«å½¢åˆ†æ
		        const shoulderWidth = Math.abs(lm[12].x - lm[11].x);
		        const torsoLength = Math.abs(lm[24].y - lm[12].y);
		        const legLength = (Math.abs(lm[28].y - lm[24].y) + Math.abs(lm[27].y - lm[23].y)) / 2;
		        const ratio = torsoLength / legLength;

		        if (ratio > 0.6) {
			        output += 'èº«å½¢ï¼šäº”äº”èº«ï¼Œå»ºè­°ç©¿è‘—é«˜è…°è¤²ã€ä¸ŠçŸ­ä¸‹é•·ã€‚\n';
		        } else {
			        output += 'èº«å½¢ï¼šå››å…­èº«ï¼Œå»ºè­°å¼·èª¿è…°ç·šèˆ‡ä¸Šèº«æ­é…ã€‚\n';
		        }
		        if (shoulderWidth > 0.15) {
			        output += 'è‚©å‹ï¼šå¯¬è‚©ï¼Œé©åˆVé ˜ã€è½è‚©è¨­è¨ˆã€‚\n';
		        } else {
			        output += 'è‚©å‹ï¼šçª„è‚©ï¼Œé©åˆæŒºç‰ˆä¸Šè¡£æˆ–æ³¡è¢–è¨­è¨ˆã€‚\n';
		        }
	        }
	        document.getElementById('poseResult').innerText = output || 'æœªåµæ¸¬åˆ°éª¨æ¶';
        });


		const cameraFace = new Camera(faceVideo, {
			onFrame: async () => {
		        if (faceVideo.readyState >= 2) {
			        await faceMesh.send({ image: faceVideo });
		        }
	        },
			width: 640,
			height: 480
		});
		cameraFace.start();

		const cameraPose = new Camera(poseVideo, {
			onFrame: async () => {
		        if (poseVideo.readyState >= 2) {
			        await pose.send({ image: poseVideo });
		        }
	        },
			width: 640,
			height: 480
		});
		cameraPose.start();
	</script>
</body>
</html>
